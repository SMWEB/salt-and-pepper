h1. Salt and Pepper

Provides automatic password hashing for ActiveRecord (>= 3.0) and a couple of methods for generating random strings, tokens, etc.
Features:

* Mark columns for auto-hashing with a single line of code in your models.
* Automatic salting of hashes. No separate column is required for the salt.
* Does not break validations on the hashed columns (only a small change is required).
* Provides convenience methods for verification.
* Tested using RSpec 2

SHA256 is used for hashing, and the SecureRandom module in Active Support is used for generating random stuff.

h2. Installation

Just add it to your Gemfile:

<pre>
gem "salt-and-pepper"
</pre>

h2. Usage

To enable automatic hashing for a column, add the *encrypt* method to your model:

<pre>
class User < ActiveRecord::Base
  encrypt :password
end
</pre>

You can specify multiple columns in one line or in separate lines:

<pre>
class User < ActiveRecord::Base
  encrypt :password, :security_token

  # or
  encrypt :password
  encrypt :security_token
end
</pre>

h3. Options

You can pass the *:length* option to change the length of the resulting hash.
Numbers between 96 and 192 are accepted, the default value is 128. Make sure the column size is in terms with that as well!

<pre>
# set length for both columns
encrypt :password, :security_token, :length => 100

# or adjust them individually
encrypt :password, :length => 160
encrypt :secret, :length => 120
</pre>

The *:skip_blank* option determines what happens when you try to save an _encrypt_-ed column with an empty value (assuming there are no validations to prevent that):

* *true* (default): empty values will not be hashed and saved. The field will keep its previous value.
* *false*: empty values will be hashed and stored (nil is treated as an empty string). This makes no sense in most situations.

This behavior makes it super easy to create "edit profile" forms that only update the user's password if a new one was entered.

h3. Verification

You can use the *==[column]==_is?* method to verify against a hashed value:

<pre>
if @user.password_is?("secret")
  # the password is correct
end
</pre>

A full example:

<pre>
# app/models/user.rb
class User < ActiveRecord::Base
  encrypt :password
end

# app/controllers/sessions_controller.rb
def create
  @user = User.find_by_username(params[:username])
  if @user.present? && @user.password_is?(params[:password])
    # log in the user here
  else
    redirect_to new_session_path, :alert => "Invalid username or password."
  end
end
</pre>

h3. Validating hashed columns

Salt and Pepper provides the *validate_[column]?* method for deciding whether validations on the column should be performed.
Use it to prevent running your sophisticated length-checking algorithms on a 128-character hash :). Skipping validation of hashed values is safe because they were already checked at the time they were set.

<pre>
class User < ActiveRecord::Base
  encrypt :password
  validates :password, :length => { :within => 6..100 }, :if => :validate_password?
end
</pre>

A common scenario is to require a password when creating a user but not when it is updated:

<pre>
class User < ActiveRecord::Base
  encrypt :password
  validates :password, :presence => { :if => :new_record? }, :length => { :within => 6..100, :allow_blank => true }, :if => :validate_password?
end
</pre>

h3. Forms

Consider a password change form:

<pre>
<%= form_for @user do |f| %>
  <%= f.password_field :password %>
  <%= f.password_field :password_confirmation %>
<% end %>
</pre>

The problem with this is that the password field will be populated with the current password's hash when displayed. To prevent this, you can use the *==[column]==_cleartext* method which returns the current value, or an empty string if the field is in a hashed state.

<pre>
<%= form_for @user do |f| %>
  <%= f.password_field :password, :value => @user.password_cleartext %>
  <%= f.password_field :password_confirmation %>
<% end %>
</pre>

This way the password field is blank when initially displayed, but properly redisplays the previous value if there was an error.

h3. Generating random stuff

Salt and Pepper has a couple of handy methods for generating random numbers, codes, tokens, etc:

<pre>
SaltPepper.random_number(6)                           # => 4     (identical to: 0..5)
SaltPepper.random_number(10..20)                      # => 11
SaltPepper.alpha_code                                 # => "SNPBJSDG"
SaltPepper.alpha_code(4)                              # => "FKNP"
SaltPepper.numeric_code                               # => "01570475"
SaltPepper.numeric_code(20)                           # => "70110124996934848762"
SaltPepper.code                                       # => "29Y3WSEC"     (alphanumeric)
SaltPepper.code(5)                                    # => "89U1F"
SaltPepper.code(10, 'a'..'z')                         # => "mqxeozlelw"
SaltPepper.code(15, (0..1).to_a + ('a'..'b').to_a)    # => "0ab1b0b1b01a0a1"
SaltPepper.token                                      # => a0d5828f79e9e22dbc1f896e49f8183a
SaltPepper.token(16)                                  # => caa4a085edb19499
</pre>

h2. License

Released under the MIT license.
Copyright (C) Máté Solymosi 2011
